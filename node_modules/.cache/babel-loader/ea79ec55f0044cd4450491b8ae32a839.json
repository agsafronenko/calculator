{"ast":null,"code":"import calculate from \"./equals\";\nexport let displayAllAfterChangeSign = \"\";\nlet expression = \"\";\nlet regex = \"\";\nlet displayAll = \"\";\nexport function changeSign(state) {\n  displayAll = state.lastResult !== \"\" ? state.lastResult : state.displayAll;\n  let changeOneIntoAnother = [\n  // the sign will be changed from positive to negative or vice versa for:\n  // 1) the expression not preceded by operators (minus here indicates negative value of the following number rather than an operator sign)\n  {\n    before: \"\\\\(\",\n    after: \"( - \"\n  }, {\n    before: \"\\\\( - \",\n    after: \"(\"\n  }, {\n    before: \"^\",\n    after: \" - \"\n  }, {\n    before: \"^ - \",\n    after: \"\"\n  },\n  // 2) the expression preceded by two consecutive operators:\n  {\n    before: \" -  - \",\n    after: \" - \"\n  }, {\n    before: \" \\\\+  - \",\n    after: \" + \"\n  }, {\n    before: \" \\\\*  - \",\n    after: \" * \"\n  }, {\n    before: \" \\\\/  - \",\n    after: \" / \"\n  }, {\n    before: \" \\\\^  - \",\n    after: \" ^ \"\n  }, {\n    before: \" yroot  - \",\n    after: \" yroot \"\n  },\n  // 3) the expression preceded by only one operator:\n  {\n    before: \" - \",\n    after: \" + \"\n  }, {\n    before: \" \\\\+ \",\n    after: \" - \"\n  }, {\n    before: \" \\\\* \",\n    after: \" *  - \"\n  }, {\n    before: \" \\\\/ \",\n    after: \" /  - \"\n  }, {\n    before: \" \\\\^ \",\n    after: \" ^  - \"\n  }, {\n    before: \" yroot \",\n    after: \" yroot  - \"\n  }];\n  findExpression(state); // determines the expression for which changeSign(state) function will be applied to\n\n  let displayCurAfterChangeSign = \"777\";\n  let arr = [];\n  for (let i = 0; i < changeOneIntoAnother.length; i++) {\n    arr.push(displayAll.match(new RegExp(`${changeOneIntoAnother[i][\"before\"]}${regex}$`)));\n  }\n  console.log(\"displayAll\", displayAll);\n  console.log(\"expression\", expression);\n  console.log(\"final\", RegExp(displayAll.match(`${changeOneIntoAnother[2][\"before\"]}${expression}$`)));\n  console.log(\"arr\", arr);\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] !== null) {\n      displayAllAfterChangeSign = displayAll.slice(0, arr[i].index).concat(changeOneIntoAnother[i][\"after\"]).concat(expression);\n      break;\n    }\n  }\n  return [displayAllAfterChangeSign, displayCurAfterChangeSign];\n  // return [displayAllAfterChangeSign, calculate(expression)];\n}\n\n// findExpression(state) determines the expression for which the sign will be changed from positive to negative or vice versa:\nfunction findExpression(state) {\n  let displayAll = state.displayAll;\n  if (state.lastResult !== \"\") displayAll = state.lastResult;\n  if (displayAll.match(/\\)\\)$/) && (state.lastOperator === \"trigonometry\" || state.lastOperator === \"abs\")) {\n    console.log(\"stage 1 start\");\n    let displayAllLength = displayAll.length;\n    let closingNum = 1;\n    let openingNum = 0;\n    let firstOpeningIndex = 0;\n    for (let i = displayAllLength - 2; i >= 0; i--) {\n      if (displayAll[i] === \")\") closingNum++;\n      if (displayAll[i] === \"(\") openingNum++;\n      if (closingNum === openingNum) {\n        firstOpeningIndex = i - 3;\n        break;\n      }\n    }\n    regex = displayAll.slice(firstOpeningIndex).replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n    expression = displayAll.slice(firstOpeningIndex);\n  } else if (displayAll.match(/\\)\\)$/ && state.lastOperator !== \"trigonometry\" && state.lastOperator !== \"abs\")) {\n    console.log(\"stage 2 start\");\n    let displayAllLength = displayAll.length;\n    let closingNum = 1;\n    let openingNum = 0;\n    let firstOpeningIndex = 0;\n    for (let i = displayAllLength - 2; i >= 0; i--) {\n      if (displayAll[i] === \")\") closingNum++;\n      if (displayAll[i] === \"(\") openingNum++;\n      if (closingNum === openingNum) {\n        firstOpeningIndex = i;\n        break;\n      }\n    }\n    regex = displayAll.slice(firstOpeningIndex).replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n    expression = displayAll.slice(firstOpeningIndex);\n  } else if (state.lastOperator === \"trigonometry\" || state.lastOperator === \"abs\") {\n    console.log(\"stage 3 start\");\n    let matchTrigOrAbs = displayAll.match(/sin|cos|tan|cot|sec|csc|abs/gi);\n    let lastTrigOrAbsIndex = displayAll.lastIndexOf(matchTrigOrAbs[matchTrigOrAbs.length - 1]);\n    regex = displayAll.slice(lastTrigOrAbsIndex).replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n    expression = displayAll.slice(lastTrigOrAbsIndex);\n  } else if (state.lastInput === \")\") {\n    console.log(\"stage 4 start\");\n    let displayAllLength = displayAll.length;\n    let closingNum = 1;\n    let openingNum = 0;\n    let firstOpeningIndex = 0;\n    for (let i = displayAllLength - 2; i >= 0; i--) {\n      if (displayAll[i] === \")\") closingNum++;\n      if (displayAll[i] === \"(\") openingNum++;\n      if (closingNum === openingNum) {\n        firstOpeningIndex = i;\n        break;\n      }\n    }\n    regex = displayAll.slice(firstOpeningIndex).replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n    expression = displayAll.slice(firstOpeningIndex);\n  } else if (state.lastInputType === \"digit\" || state.lastInputType === \"decimal\") {\n    console.log(\"stage 5 start\");\n    regex = displayAll.match(/\\d+(?:\\.\\d*)?$/);\n    expression = regex;\n  } else if (state.lastInputType === \"!\" || state.lastInputType === \"%\") {\n    console.log(\"stage 6 start\");\n    regex = displayAll.match(/\\d+(?:\\.\\d*)?(!%|%!|!|%)$/)[0];\n    expression = regex;\n  }\n}","map":{"version":3,"names":["calculate","displayAllAfterChangeSign","expression","regex","displayAll","changeSign","state","lastResult","changeOneIntoAnother","before","after","findExpression","displayCurAfterChangeSign","arr","i","length","push","match","RegExp","console","log","slice","index","concat","lastOperator","displayAllLength","closingNum","openingNum","firstOpeningIndex","replace","matchTrigOrAbs","lastTrigOrAbsIndex","lastIndexOf","lastInput","lastInputType"],"sources":["C:/Users/agsaf/Documents/GitHub/calculator/src/functions/changeSign.js"],"sourcesContent":["import calculate from \"./equals\";\r\n\r\nexport let displayAllAfterChangeSign = \"\";\r\nlet expression = \"\";\r\nlet regex = \"\";\r\nlet displayAll = \"\";\r\n\r\nexport function changeSign(state) {\r\n  displayAll = state.lastResult !== \"\" ? state.lastResult : state.displayAll;\r\n\r\n  let changeOneIntoAnother = [\r\n    // the sign will be changed from positive to negative or vice versa for:\r\n    // 1) the expression not preceded by operators (minus here indicates negative value of the following number rather than an operator sign)\r\n    {\r\n      before: \"\\\\(\",\r\n      after: \"( - \",\r\n    },\r\n    {\r\n      before: \"\\\\( - \",\r\n      after: \"(\",\r\n    },\r\n    {\r\n      before: \"^\",\r\n      after: \" - \",\r\n    },\r\n    {\r\n      before: \"^ - \",\r\n      after: \"\",\r\n    },\r\n\r\n    // 2) the expression preceded by two consecutive operators:\r\n    {\r\n      before: \" -  - \",\r\n      after: \" - \",\r\n    },\r\n    {\r\n      before: \" \\\\+  - \",\r\n      after: \" + \",\r\n    },\r\n    {\r\n      before: \" \\\\*  - \",\r\n      after: \" * \",\r\n    },\r\n    {\r\n      before: \" \\\\/  - \",\r\n      after: \" / \",\r\n    },\r\n    {\r\n      before: \" \\\\^  - \",\r\n      after: \" ^ \",\r\n    },\r\n    {\r\n      before: \" yroot  - \",\r\n      after: \" yroot \",\r\n    },\r\n    // 3) the expression preceded by only one operator:\r\n    {\r\n      before: \" - \",\r\n      after: \" + \",\r\n    },\r\n    {\r\n      before: \" \\\\+ \",\r\n      after: \" - \",\r\n    },\r\n    {\r\n      before: \" \\\\* \",\r\n      after: \" *  - \",\r\n    },\r\n    {\r\n      before: \" \\\\/ \",\r\n      after: \" /  - \",\r\n    },\r\n    {\r\n      before: \" \\\\^ \",\r\n      after: \" ^  - \",\r\n    },\r\n    {\r\n      before: \" yroot \",\r\n      after: \" yroot  - \",\r\n    },\r\n  ];\r\n\r\n  findExpression(state); // determines the expression for which changeSign(state) function will be applied to\r\n\r\n  let displayCurAfterChangeSign = \"777\";\r\n\r\n  let arr = [];\r\n  for (let i = 0; i < changeOneIntoAnother.length; i++) {\r\n    arr.push(displayAll.match(new RegExp(`${changeOneIntoAnother[i][\"before\"]}${regex}$`)));\r\n  }\r\n  console.log(\"displayAll\", displayAll);\r\n  console.log(\"expression\", expression);\r\n  console.log(\"final\", RegExp(displayAll.match(`${changeOneIntoAnother[2][\"before\"]}${expression}$`)));\r\n  console.log(\"arr\", arr);\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] !== null) {\r\n      displayAllAfterChangeSign = displayAll.slice(0, arr[i].index).concat(changeOneIntoAnother[i][\"after\"]).concat(expression);\r\n      break;\r\n    }\r\n  }\r\n  return [displayAllAfterChangeSign, displayCurAfterChangeSign];\r\n  // return [displayAllAfterChangeSign, calculate(expression)];\r\n}\r\n\r\n// findExpression(state) determines the expression for which the sign will be changed from positive to negative or vice versa:\r\nfunction findExpression(state) {\r\n  let displayAll = state.displayAll;\r\n  if (state.lastResult !== \"\") displayAll = state.lastResult;\r\n  if (displayAll.match(/\\)\\)$/) && (state.lastOperator === \"trigonometry\" || state.lastOperator === \"abs\")) {\r\n    console.log(\"stage 1 start\");\r\n    let displayAllLength = displayAll.length;\r\n    let closingNum = 1;\r\n    let openingNum = 0;\r\n    let firstOpeningIndex = 0;\r\n    for (let i = displayAllLength - 2; i >= 0; i--) {\r\n      if (displayAll[i] === \")\") closingNum++;\r\n      if (displayAll[i] === \"(\") openingNum++;\r\n      if (closingNum === openingNum) {\r\n        firstOpeningIndex = i - 3;\r\n        break;\r\n      }\r\n    }\r\n\r\n    regex = displayAll.slice(firstOpeningIndex).replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\r\n    expression = displayAll.slice(firstOpeningIndex);\r\n  } else if (displayAll.match(/\\)\\)$/ && state.lastOperator !== \"trigonometry\" && state.lastOperator !== \"abs\")) {\r\n    console.log(\"stage 2 start\");\r\n    let displayAllLength = displayAll.length;\r\n    let closingNum = 1;\r\n    let openingNum = 0;\r\n    let firstOpeningIndex = 0;\r\n    for (let i = displayAllLength - 2; i >= 0; i--) {\r\n      if (displayAll[i] === \")\") closingNum++;\r\n      if (displayAll[i] === \"(\") openingNum++;\r\n      if (closingNum === openingNum) {\r\n        firstOpeningIndex = i;\r\n        break;\r\n      }\r\n    }\r\n    regex = displayAll.slice(firstOpeningIndex).replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\r\n    expression = displayAll.slice(firstOpeningIndex);\r\n  } else if (state.lastOperator === \"trigonometry\" || state.lastOperator === \"abs\") {\r\n    console.log(\"stage 3 start\");\r\n    let matchTrigOrAbs = displayAll.match(/sin|cos|tan|cot|sec|csc|abs/gi);\r\n    let lastTrigOrAbsIndex = displayAll.lastIndexOf(matchTrigOrAbs[matchTrigOrAbs.length - 1]);\r\n    regex = displayAll.slice(lastTrigOrAbsIndex).replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\r\n    expression = displayAll.slice(lastTrigOrAbsIndex);\r\n  } else if (state.lastInput === \")\") {\r\n    console.log(\"stage 4 start\");\r\n    let displayAllLength = displayAll.length;\r\n    let closingNum = 1;\r\n    let openingNum = 0;\r\n    let firstOpeningIndex = 0;\r\n    for (let i = displayAllLength - 2; i >= 0; i--) {\r\n      if (displayAll[i] === \")\") closingNum++;\r\n      if (displayAll[i] === \"(\") openingNum++;\r\n      if (closingNum === openingNum) {\r\n        firstOpeningIndex = i;\r\n        break;\r\n      }\r\n    }\r\n    regex = displayAll.slice(firstOpeningIndex).replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\r\n    expression = displayAll.slice(firstOpeningIndex);\r\n  } else if (state.lastInputType === \"digit\" || state.lastInputType === \"decimal\") {\r\n    console.log(\"stage 5 start\");\r\n    regex = displayAll.match(/\\d+(?:\\.\\d*)?$/);\r\n    expression = regex;\r\n  } else if (state.lastInputType === \"!\" || state.lastInputType === \"%\") {\r\n    console.log(\"stage 6 start\");\r\n    regex = displayAll.match(/\\d+(?:\\.\\d*)?(!%|%!|!|%)$/)[0];\r\n    expression = regex;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}