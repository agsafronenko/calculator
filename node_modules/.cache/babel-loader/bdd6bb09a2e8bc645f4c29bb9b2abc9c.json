{"ast":null,"code":"import { expression, findExpression } from \"./findExpression\";\nimport calculate from \"./equals\";\n\n// let stateForFactorial = \"\";\n// export function factorialState(state) {\n//   stateForFactorial = state;\n// }\n\nexport let alertStatus = {\n  negative: false,\n  nonInteger: false\n};\nexport function factorial(num) {\n  if (num < 0) {\n    if (alertStatus.negative === false) {\n      alert(\"invalid input: factorials are only defined for positive numbers\");\n      alertStatus.negative = true;\n    }\n    return \"invalid input\";\n  } else if (num % 1 !== 0) {\n    if (alertStatus.nonInteger === false) {\n      alert(`factorials for nonintegers are defined based on simplified Gamma function:\n      ~~ level of accuracy: low ~~`);\n      alertStatus.nonInteger = true;\n    }\n    return Math.pow(2 * num * Math.PI, 1 / 2) * Math.pow(num / Math.E, num);\n  } else {\n    let result = Number(num);\n    if (Number.isInteger(result)) {\n      for (let i = result - 1; i > 0; i--) {\n        result *= i;\n      }\n      return result;\n    }\n  }\n}\n\n// export function factorial(num) {\n//   if (num < 0) {\n//     if (alertStatus.negative === false) {\n//       alert(\"invalid input: factorials are only defined for positive numbers\");\n//       alertStatus.negative = true;\n//     }\n//     return \"invalid input\";\n//   } else if (num % 1 !== 0 && num !== \")\") {\n//     findExpression(stateForFactorial);\n//     let result = calculate(stateForFactorial, expression);\n//     if (result % 1 !== 0) {\n//       if (alertStatus.nonInteger === false) {\n//         alert(`factorials for nonintegers are defined based on simplified Gamma function:\n//       ~~ level of accuracy: low ~~`);\n//         alertStatus.nonInteger = true;\n//       }\n//     }\n//     return Math.pow(2 * num * Math.PI, 1 / 2) * Math.pow(num / Math.E, num);\n//   } else if (num === \")\") {\n//     return \"!\";\n//   } else {\n//     let result = Number(num);\n//     if (Number.isInteger(result)) {\n//       for (let i = result - 1; i > 0; i--) {\n//         result *= i;\n//       }\n//       return result;\n//     }\n//   }\n// }","map":{"version":3,"names":["expression","findExpression","calculate","alertStatus","negative","nonInteger","factorial","num","alert","Math","pow","PI","E","result","Number","isInteger","i"],"sources":["C:/Users/agsaf/Documents/GitHub/calculator/src/functions/factorial.js"],"sourcesContent":["import { expression, findExpression } from \"./findExpression\";\r\nimport calculate from \"./equals\";\r\n\r\n// let stateForFactorial = \"\";\r\n// export function factorialState(state) {\r\n//   stateForFactorial = state;\r\n// }\r\n\r\nexport let alertStatus = {\r\n  negative: false,\r\n  nonInteger: false,\r\n};\r\n\r\nexport function factorial(num) {\r\n  if (num < 0) {\r\n    if (alertStatus.negative === false) {\r\n      alert(\"invalid input: factorials are only defined for positive numbers\");\r\n      alertStatus.negative = true;\r\n    }\r\n    return \"invalid input\";\r\n  } else if (num % 1 !== 0) {\r\n    if (alertStatus.nonInteger === false) {\r\n      alert(`factorials for nonintegers are defined based on simplified Gamma function:\r\n      ~~ level of accuracy: low ~~`);\r\n      alertStatus.nonInteger = true;\r\n    }\r\n    return Math.pow(2 * num * Math.PI, 1 / 2) * Math.pow(num / Math.E, num);\r\n  } else {\r\n    let result = Number(num);\r\n    if (Number.isInteger(result)) {\r\n      for (let i = result - 1; i > 0; i--) {\r\n        result *= i;\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n}\r\n\r\n// export function factorial(num) {\r\n//   if (num < 0) {\r\n//     if (alertStatus.negative === false) {\r\n//       alert(\"invalid input: factorials are only defined for positive numbers\");\r\n//       alertStatus.negative = true;\r\n//     }\r\n//     return \"invalid input\";\r\n//   } else if (num % 1 !== 0 && num !== \")\") {\r\n//     findExpression(stateForFactorial);\r\n//     let result = calculate(stateForFactorial, expression);\r\n//     if (result % 1 !== 0) {\r\n//       if (alertStatus.nonInteger === false) {\r\n//         alert(`factorials for nonintegers are defined based on simplified Gamma function:\r\n//       ~~ level of accuracy: low ~~`);\r\n//         alertStatus.nonInteger = true;\r\n//       }\r\n//     }\r\n//     return Math.pow(2 * num * Math.PI, 1 / 2) * Math.pow(num / Math.E, num);\r\n//   } else if (num === \")\") {\r\n//     return \"!\";\r\n//   } else {\r\n//     let result = Number(num);\r\n//     if (Number.isInteger(result)) {\r\n//       for (let i = result - 1; i > 0; i--) {\r\n//         result *= i;\r\n//       }\r\n//       return result;\r\n//     }\r\n//   }\r\n// }\r\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,cAAc,QAAQ,kBAAkB;AAC7D,OAAOC,SAAS,MAAM,UAAU;;AAEhC;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,WAAW,GAAG;EACvBC,QAAQ,EAAE,KAAK;EACfC,UAAU,EAAE;AACd,CAAC;AAED,OAAO,SAASC,SAAS,CAACC,GAAG,EAAE;EAC7B,IAAIA,GAAG,GAAG,CAAC,EAAE;IACX,IAAIJ,WAAW,CAACC,QAAQ,KAAK,KAAK,EAAE;MAClCI,KAAK,CAAC,iEAAiE,CAAC;MACxEL,WAAW,CAACC,QAAQ,GAAG,IAAI;IAC7B;IACA,OAAO,eAAe;EACxB,CAAC,MAAM,IAAIG,GAAG,GAAG,CAAC,KAAK,CAAC,EAAE;IACxB,IAAIJ,WAAW,CAACE,UAAU,KAAK,KAAK,EAAE;MACpCG,KAAK,CAAE;AACb,mCAAmC,CAAC;MAC9BL,WAAW,CAACE,UAAU,GAAG,IAAI;IAC/B;IACA,OAAOI,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGH,GAAG,GAAGE,IAAI,CAACE,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,GAAGF,IAAI,CAACC,GAAG,CAACH,GAAG,GAAGE,IAAI,CAACG,CAAC,EAAEL,GAAG,CAAC;EACzE,CAAC,MAAM;IACL,IAAIM,MAAM,GAAGC,MAAM,CAACP,GAAG,CAAC;IACxB,IAAIO,MAAM,CAACC,SAAS,CAACF,MAAM,CAAC,EAAE;MAC5B,KAAK,IAAIG,CAAC,GAAGH,MAAM,GAAG,CAAC,EAAEG,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACnCH,MAAM,IAAIG,CAAC;MACb;MACA,OAAOH,MAAM;IACf;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}