{"ast":null,"code":"// logic for braces:\n// 1) when clicking \"=\" => create external braces for the whole \"result\" are via unshift and push (this will be handy in step 4 \"recursion\");\n// 2) create main (outer) function \"calculate(arr)\" for calculating final result which will use existing \"calculate(arr)\" (rename it to \"calculateInsideBraces(arr)\") for internal calculations inside the braces, make sure main (outer) function is executed when clicking \"=\" sign in App.js;\n// 3) inside new function:\n// - use findIndex to find the first closing brace \")\"\n// - slice arr until this index\n// - reverse sliced arr and find the first opening brace \"(\"\n// - reverse arr and slice it (arr.length - index of \"(\", index of \")\") => this will give us the depeest level inside the braces after THE FIRST OPENING brace;\n// - remove braces of the deepest level (better do this in previous step -> just count properly indeces before the last slice);\n// execute \"calculateInsideBraces(arr)\" for the expression inside the deepest level,\n// - return result back inside the \"result\" arr;\n// 4) use recursion for step 3 until all expressions are evaluated\n// 5) return result on calc's display\n\n// apply the following restrictions:\n// - do not allow to input opening brace \"(\" after the digit;\n// - allow to input closing brace \")\" only after the digit;\n// - if number of opening braces is more that the number of closing -> add closing braces automatically in the end of the expression (both in \"result\" and in \"displayOps\")\n// - check what happens when the operator is put after the opening brace;\n// - check what happens when the digit is put after the closing brace;\n\nexport default function calculate(expr) {\n  // console.log(\"diplayOps in calculate(arr)\", expr);\n  console.clear();\n  expr = convertDisplayOpsIntoArray(expr);\n  let fjdfjdlsfk = findParenthesis(expr);\n  // return calculateInsideParentheses(expr);\n}\n\nfunction convertDisplayOpsIntoArray(string) {\n  let parseRegex = new RegExp(/\\d+\\.\\d+| yroot | log base | mod | \\+ | - | \\* | \\^ | \\/ |\\d+|\\D/, \"g\");\n  let displayOpsArray = string.match(parseRegex).map(elem => isFinite(elem) ? Number(elem) : elem);\n  displayOpsArray.unshift(\"(\");\n  displayOpsArray.push(\")\");\n  console.log(\"match\", displayOpsArray);\n  return displayOpsArray;\n}\n// 3) inside new function:\n// - use findIndex to find the first closing brace \")\"\n// - slice arr until this index\n// - reverse sliced arr and find the first opening brace \"(\"\n// - reverse arr and slice it (arr.length - index of \"(\", index of \")\") => this will give us the depeest level inside the braces after THE FIRST OPENING brace;\n// - remove braces of the deepest level (better do this in previous step -> just count properly indeces before the last slice);\n// execute \"calculateInsideBraces(arr)\" for the expression inside the deepest level,\n// - return result back inside the \"result\" arr;\nfunction findParenthesis(expr) {\n  let firstClosingIndex = expr.findIndex(parentesis => parentesis === \")\");\n  if (firstClosingIndex !== -1) {\n    // console.log(\"firstClosingIndex\", firstClosingIndex);\n    let exprInsideParantethes = expr.slice(0, firstClosingIndex);\n    let firstOpeningIndex = exprInsideParantethes.reverse().findIndex(parentesis => parentesis === \"(\");\n    exprInsideParantethes = exprInsideParantethes.slice(0, firstOpeningIndex).reverse();\n    // console.log(\"exprInsidePaentheses\", expr);\n    let resultInsideParentheses = calculateInsideParentheses(exprInsideParantethes);\n    console.log(\"resultInsideParentheses\", resultInsideParentheses);\n    // console.log(\"closinInd\", firstClosingIndex, \"openInd\", firstOpeningIndex);\n    expr = expr.slice(0, firstClosingIndex - firstOpeningIndex - 1).concat(resultInsideParentheses).concat(expr.slice(firstClosingIndex + 1));\n    console.log(\"expr after replace\", expr);\n    findParenthesis(expr);\n  }\n}\nfunction calculateInsideParentheses(expr) {\n  expr = findNegativeValues(expr);\n  expr = calculateInOrder(expr, [\" log base \", \" mod \"]);\n  expr = calculateInOrder(expr, [\" ^ \", \" yroot \"]);\n  expr = calculateInOrder(expr, [\" * \", \" / \"]);\n  expr = calculateInOrder(expr, [\" + \", \" - \"]);\n  return expr[0];\n}\nfunction findNegativeValues(arr) {\n  // console.log(\"arr inside calculate\", arr);\n  let negativeIndex = arr.findIndex((elem, ind) => elem === \" - \" && typeof arr[ind - 1] === \"string\" && typeof arr[ind + 1] === \"number\");\n  // console.log(\"negativeIndex\", negativeIndex);\n  if (negativeIndex !== -1) {\n    let newArr = arr.slice(0, negativeIndex).concat(arr[negativeIndex + 1] * -1).concat(arr.slice(negativeIndex + 2));\n    return findNegativeValues(newArr);\n  }\n  // console.log(\"arr\", arr);\n  return arr;\n}\nfunction calculateInOrder(arr, operators) {\n  // console.log(\"inside SameOperations\", arr, operators);\n  let operatorIndex = arr.findIndex(elem => elem === operators[0] || elem === operators[1]);\n  let currentOperator = arr[operatorIndex];\n  if (operatorIndex !== -1) {\n    let currentOperation = arr.slice(operatorIndex - 1, operatorIndex + 2);\n    let currentResult = currentOperator === \" log base \" ? Math.log(currentOperation[0]) / Math.log(currentOperation[2]) : currentOperator === \" mod \" ? currentOperation[0] % currentOperation[2] : currentOperator === \" yroot \" ? Math.pow(currentOperation[0], 1 / currentOperation[2]) : currentOperator === \" ^ \" ? Math.pow(currentOperation[0], currentOperation[2]) : currentOperator === \" * \" ? currentOperation[0] * currentOperation[2] : currentOperator === \" / \" ? currentOperation[0] / currentOperation[2] : currentOperator === \" + \" ? currentOperation[0] + currentOperation[2] : currentOperation[0] - currentOperation[2];\n    let result = arr.slice(0, operatorIndex - 1).concat(currentResult).concat(arr.slice(operatorIndex + 2));\n    return calculateInOrder(result, operators);\n  }\n  // console.log(\"inside SameOperations before return\", arr, operator);\n  return arr;\n}\nexport let displayOpsExpression = \"\";\nexport function deleteRedundantOperators(state) {\n  if (/\\)/.test(state.displayCur)) {\n    displayOpsExpression = state.displayOps;\n  } else if (/\\d/.test(state.displayCur)) {\n    displayOpsExpression = state.displayOps.concat(Number(state.displayCur));\n  } else {\n    let lastDigitIndex = state.result.reverse().findIndex(elem => /\\d/.test(elem));\n    displayOpsExpression = state.displayOps.slice(0, state.displayOps.length - lastDigitIndex);\n  }\n}\n\n// export function deleteRedundantDigits(state) {\n//   if (/\\./.test(state.displayCur)) {\n//     let decimalIndex = state.displayOps\n//       .split(\"\")\n//       .reverse()\n//       .findIndex((elem) => /\\./.test(elem));\n//     displayOpsExpression = state.displayOps.slice(0, state.displayOps.length - decimalIndex - 2);\n//   } else if (/\\D/.test(state.displayCur)) {\n//     displayOpsExpression = state.displayOps;\n//   } else {\n//     let lastNonDigitIndex = state.displayOps\n//       .split(\"\")\n//       .reverse()\n//       .findIndex((elem) => /\\D/.test(elem));\n//     displayOpsExpression = lastNonDigitIndex === -1 ? \"\" : state.displayOps.slice(0, state.displayOps.length - lastNonDigitIndex);\n//   }\n// }\n\nexport let stateStorage = {\n  prevState: []\n};\nexport function saveState(state) {\n  if (stateStorage.prevState.length >= 30) {\n    stateStorage.prevState.pop();\n    stateStorage.prevState.unshift(state);\n  } else {\n    stateStorage.prevState.unshift(state);\n  }\n  return stateStorage.prevState;\n}\nexport function factorial(num) {\n  let result = Number(num);\n  if (Number.isInteger(result)) {\n    for (let i = result - 1; i > 0; i--) {\n      result *= i;\n    }\n  }\n  return Number.isInteger(result) ? result : num;\n}\nexport function trigonometryInDegrees(curDegree, trigFunc) {\n  console.log(\"inside trigonom, args:\", curDegree, trigFunc);\n  let reciprocal = {\n    cot: \"tan\",\n    sec: \"cos\",\n    csc: \"sin\"\n  };\n  let calculateResult = Function(`return ${trigFunc} === cot || ${trigFunc} === sec || ${trigFunc} === csc ? 1/ Math.${reciprocal[trigFunc]}(${curDegree} * (Math.PI / 180)) : Math.${trigFunc}(${curDegree} * (Math.PI / 180))`);\n  return calculateResult().toString();\n}","map":{"version":3,"names":["calculate","expr","console","clear","convertDisplayOpsIntoArray","fjdfjdlsfk","findParenthesis","string","parseRegex","RegExp","displayOpsArray","match","map","elem","isFinite","Number","unshift","push","log","firstClosingIndex","findIndex","parentesis","exprInsideParantethes","slice","firstOpeningIndex","reverse","resultInsideParentheses","calculateInsideParentheses","concat","findNegativeValues","calculateInOrder","arr","negativeIndex","ind","newArr","operators","operatorIndex","currentOperator","currentOperation","currentResult","Math","pow","result","displayOpsExpression","deleteRedundantOperators","state","test","displayCur","displayOps","lastDigitIndex","length","stateStorage","prevState","saveState","pop","factorial","num","isInteger","i","trigonometryInDegrees","curDegree","trigFunc","reciprocal","cot","sec","csc","calculateResult","Function","toString"],"sources":["C:/Users/agsaf/Documents/GitHub/calculator/src/functions.js"],"sourcesContent":["// logic for braces:\r\n// 1) when clicking \"=\" => create external braces for the whole \"result\" are via unshift and push (this will be handy in step 4 \"recursion\");\r\n// 2) create main (outer) function \"calculate(arr)\" for calculating final result which will use existing \"calculate(arr)\" (rename it to \"calculateInsideBraces(arr)\") for internal calculations inside the braces, make sure main (outer) function is executed when clicking \"=\" sign in App.js;\r\n// 3) inside new function:\r\n// - use findIndex to find the first closing brace \")\"\r\n// - slice arr until this index\r\n// - reverse sliced arr and find the first opening brace \"(\"\r\n// - reverse arr and slice it (arr.length - index of \"(\", index of \")\") => this will give us the depeest level inside the braces after THE FIRST OPENING brace;\r\n// - remove braces of the deepest level (better do this in previous step -> just count properly indeces before the last slice);\r\n// execute \"calculateInsideBraces(arr)\" for the expression inside the deepest level,\r\n// - return result back inside the \"result\" arr;\r\n// 4) use recursion for step 3 until all expressions are evaluated\r\n// 5) return result on calc's display\r\n\r\n// apply the following restrictions:\r\n// - do not allow to input opening brace \"(\" after the digit;\r\n// - allow to input closing brace \")\" only after the digit;\r\n// - if number of opening braces is more that the number of closing -> add closing braces automatically in the end of the expression (both in \"result\" and in \"displayOps\")\r\n// - check what happens when the operator is put after the opening brace;\r\n// - check what happens when the digit is put after the closing brace;\r\n\r\nexport default function calculate(expr) {\r\n  // console.log(\"diplayOps in calculate(arr)\", expr);\r\n  console.clear();\r\n  expr = convertDisplayOpsIntoArray(expr);\r\n  let fjdfjdlsfk = findParenthesis(expr);\r\n  // return calculateInsideParentheses(expr);\r\n}\r\n\r\nfunction convertDisplayOpsIntoArray(string) {\r\n  let parseRegex = new RegExp(/\\d+\\.\\d+| yroot | log base | mod | \\+ | - | \\* | \\^ | \\/ |\\d+|\\D/, \"g\");\r\n  let displayOpsArray = string.match(parseRegex).map((elem) => (isFinite(elem) ? Number(elem) : elem));\r\n  displayOpsArray.unshift(\"(\");\r\n  displayOpsArray.push(\")\");\r\n  console.log(\"match\", displayOpsArray);\r\n  return displayOpsArray;\r\n}\r\n// 3) inside new function:\r\n// - use findIndex to find the first closing brace \")\"\r\n// - slice arr until this index\r\n// - reverse sliced arr and find the first opening brace \"(\"\r\n// - reverse arr and slice it (arr.length - index of \"(\", index of \")\") => this will give us the depeest level inside the braces after THE FIRST OPENING brace;\r\n// - remove braces of the deepest level (better do this in previous step -> just count properly indeces before the last slice);\r\n// execute \"calculateInsideBraces(arr)\" for the expression inside the deepest level,\r\n// - return result back inside the \"result\" arr;\r\nfunction findParenthesis(expr) {\r\n  let firstClosingIndex = expr.findIndex((parentesis) => parentesis === \")\");\r\n  if (firstClosingIndex !== -1) {\r\n    // console.log(\"firstClosingIndex\", firstClosingIndex);\r\n    let exprInsideParantethes = expr.slice(0, firstClosingIndex);\r\n    let firstOpeningIndex = exprInsideParantethes.reverse().findIndex((parentesis) => parentesis === \"(\");\r\n    exprInsideParantethes = exprInsideParantethes.slice(0, firstOpeningIndex).reverse();\r\n    // console.log(\"exprInsidePaentheses\", expr);\r\n    let resultInsideParentheses = calculateInsideParentheses(exprInsideParantethes);\r\n    console.log(\"resultInsideParentheses\", resultInsideParentheses);\r\n    // console.log(\"closinInd\", firstClosingIndex, \"openInd\", firstOpeningIndex);\r\n    expr = expr\r\n      .slice(0, firstClosingIndex - firstOpeningIndex - 1)\r\n      .concat(resultInsideParentheses)\r\n      .concat(expr.slice(firstClosingIndex + 1));\r\n    console.log(\"expr after replace\", expr);\r\n    findParenthesis(expr);\r\n  }\r\n}\r\n\r\nfunction calculateInsideParentheses(expr) {\r\n  expr = findNegativeValues(expr);\r\n  expr = calculateInOrder(expr, [\" log base \", \" mod \"]);\r\n  expr = calculateInOrder(expr, [\" ^ \", \" yroot \"]);\r\n  expr = calculateInOrder(expr, [\" * \", \" / \"]);\r\n  expr = calculateInOrder(expr, [\" + \", \" - \"]);\r\n\r\n  return expr[0];\r\n}\r\n\r\nfunction findNegativeValues(arr) {\r\n  // console.log(\"arr inside calculate\", arr);\r\n  let negativeIndex = arr.findIndex((elem, ind) => elem === \" - \" && typeof arr[ind - 1] === \"string\" && typeof arr[ind + 1] === \"number\");\r\n  // console.log(\"negativeIndex\", negativeIndex);\r\n  if (negativeIndex !== -1) {\r\n    let newArr = arr\r\n      .slice(0, negativeIndex)\r\n      .concat(arr[negativeIndex + 1] * -1)\r\n      .concat(arr.slice(negativeIndex + 2));\r\n    return findNegativeValues(newArr);\r\n  }\r\n  // console.log(\"arr\", arr);\r\n  return arr;\r\n}\r\n\r\nfunction calculateInOrder(arr, operators) {\r\n  // console.log(\"inside SameOperations\", arr, operators);\r\n  let operatorIndex = arr.findIndex((elem) => elem === operators[0] || elem === operators[1]);\r\n  let currentOperator = arr[operatorIndex];\r\n\r\n  if (operatorIndex !== -1) {\r\n    let currentOperation = arr.slice(operatorIndex - 1, operatorIndex + 2);\r\n\r\n    let currentResult =\r\n      currentOperator === \" log base \"\r\n        ? Math.log(currentOperation[0]) / Math.log(currentOperation[2])\r\n        : currentOperator === \" mod \"\r\n        ? currentOperation[0] % currentOperation[2]\r\n        : currentOperator === \" yroot \"\r\n        ? Math.pow(currentOperation[0], 1 / currentOperation[2])\r\n        : currentOperator === \" ^ \"\r\n        ? Math.pow(currentOperation[0], currentOperation[2])\r\n        : currentOperator === \" * \"\r\n        ? currentOperation[0] * currentOperation[2]\r\n        : currentOperator === \" / \"\r\n        ? currentOperation[0] / currentOperation[2]\r\n        : currentOperator === \" + \"\r\n        ? currentOperation[0] + currentOperation[2]\r\n        : currentOperation[0] - currentOperation[2];\r\n\r\n    let result = arr\r\n      .slice(0, operatorIndex - 1)\r\n      .concat(currentResult)\r\n      .concat(arr.slice(operatorIndex + 2));\r\n\r\n    return calculateInOrder(result, operators);\r\n  }\r\n  // console.log(\"inside SameOperations before return\", arr, operator);\r\n  return arr;\r\n}\r\n\r\nexport let displayOpsExpression = \"\";\r\n\r\nexport function deleteRedundantOperators(state) {\r\n  if (/\\)/.test(state.displayCur)) {\r\n    displayOpsExpression = state.displayOps;\r\n  } else if (/\\d/.test(state.displayCur)) {\r\n    displayOpsExpression = state.displayOps.concat(Number(state.displayCur));\r\n  } else {\r\n    let lastDigitIndex = state.result.reverse().findIndex((elem) => /\\d/.test(elem));\r\n    displayOpsExpression = state.displayOps.slice(0, state.displayOps.length - lastDigitIndex);\r\n  }\r\n}\r\n\r\n// export function deleteRedundantDigits(state) {\r\n//   if (/\\./.test(state.displayCur)) {\r\n//     let decimalIndex = state.displayOps\r\n//       .split(\"\")\r\n//       .reverse()\r\n//       .findIndex((elem) => /\\./.test(elem));\r\n//     displayOpsExpression = state.displayOps.slice(0, state.displayOps.length - decimalIndex - 2);\r\n//   } else if (/\\D/.test(state.displayCur)) {\r\n//     displayOpsExpression = state.displayOps;\r\n//   } else {\r\n//     let lastNonDigitIndex = state.displayOps\r\n//       .split(\"\")\r\n//       .reverse()\r\n//       .findIndex((elem) => /\\D/.test(elem));\r\n//     displayOpsExpression = lastNonDigitIndex === -1 ? \"\" : state.displayOps.slice(0, state.displayOps.length - lastNonDigitIndex);\r\n//   }\r\n// }\r\n\r\nexport let stateStorage = {\r\n  prevState: [],\r\n};\r\n\r\nexport function saveState(state) {\r\n  if (stateStorage.prevState.length >= 30) {\r\n    stateStorage.prevState.pop();\r\n    stateStorage.prevState.unshift(state);\r\n  } else {\r\n    stateStorage.prevState.unshift(state);\r\n  }\r\n  return stateStorage.prevState;\r\n}\r\n\r\nexport function factorial(num) {\r\n  let result = Number(num);\r\n  if (Number.isInteger(result)) {\r\n    for (let i = result - 1; i > 0; i--) {\r\n      result *= i;\r\n    }\r\n  }\r\n  return Number.isInteger(result) ? result : num;\r\n}\r\n\r\nexport function trigonometryInDegrees(curDegree, trigFunc) {\r\n  console.log(\"inside trigonom, args:\", curDegree, trigFunc);\r\n  let reciprocal = {\r\n    cot: \"tan\",\r\n    sec: \"cos\",\r\n    csc: \"sin\",\r\n  };\r\n\r\n  let calculateResult = Function(`return ${trigFunc} === cot || ${trigFunc} === sec || ${trigFunc} === csc ? 1/ Math.${reciprocal[trigFunc]}(${curDegree} * (Math.PI / 180)) : Math.${trigFunc}(${curDegree} * (Math.PI / 180))`);\r\n  return calculateResult().toString();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}