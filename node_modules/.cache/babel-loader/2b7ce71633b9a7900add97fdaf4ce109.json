{"ast":null,"code":"import calculate from \"./equals\";\nimport { expression, regex, findExpression } from \"./findExpression\";\nexport let displayAllafterChangeSign = \"\";\nlet displayAll = \"\";\nexport function changeSign(state) {\n  displayAll = state.lastResult !== \"\" ? state.lastResult : state.displayAll;\n  let changeOneIntoAnother = [\n  // the sign will be changed from positive to negative or vice versa for:\n  // 1) the expression not preceded by operators (minus here indicates negative value of the following number rather than an operator sign)\n  {\n    before: \"\\\\(\",\n    afterChangeSign: \"( - \"\n  }, {\n    before: \"\\\\( - \",\n    afterChangeSign: \"(\"\n  }, {\n    before: \"^\",\n    afterChangeSign: \" - \"\n  }, {\n    before: \"^ - \",\n    afterChangeSign: \"\"\n  },\n  // 2) the expression preceded by two consecutive operators:\n  {\n    before: \" -  - \",\n    afterChangeSign: \" - \"\n  }, {\n    before: \" \\\\+  - \",\n    afterChangeSign: \" + \"\n  }, {\n    before: \" \\\\*  - \",\n    afterChangeSign: \" * \"\n  }, {\n    before: \" \\\\/  - \",\n    afterChangeSign: \" / \"\n  }, {\n    before: \" \\\\^  - \",\n    afterChangeSign: \" ^ \"\n  }, {\n    before: \" yroot  - \",\n    afterChangeSign: \" yroot \"\n  }, {\n    before: \" mod  - \",\n    afterChangeSign: \" mod \"\n  },\n  // 3) the expression preceded by only one operator:\n  {\n    before: \" - \",\n    afterChangeSign: \" + \"\n  }, {\n    before: \" \\\\+ \",\n    afterChangeSign: \" - \"\n  }, {\n    before: \" \\\\* \",\n    afterChangeSign: \" *  - \"\n  }, {\n    before: \" \\\\/ \",\n    afterChangeSign: \" /  - \"\n  }, {\n    before: \" \\\\^ \",\n    afterChangeSign: \" ^  - \"\n  }, {\n    before: \" yroot \",\n    afterChangeSign: \" yroot  - \"\n  }, {\n    before: \" mod \",\n    afterChangeSign: \" mod \"\n  }];\n  findExpression(state); // determines the expression for which changeSign(state) function will be applied to\n\n  let arr = [];\n  for (let i = 0; i < changeOneIntoAnother.length; i++) {\n    arr.push(displayAll.match(new RegExp(`${changeOneIntoAnother[i][\"before\"]}${regex}$`)));\n  }\n  // console.log(\"displayAll\", displayAll);\n  // console.log(\"expression\", expression);\n  // console.log(\"final\", RegExp(displayAll.match(`${changeOneIntoAnother[2][\"before\"]}${expression}$`)));\n  // console.log(\"arr\", arr);\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] !== null) {\n      displayAllafterChangeSign = displayAll.slice(0, arr[i].index).concat(changeOneIntoAnother[i][\"afterChangeSign\"]).concat(expression);\n      break;\n    }\n  }\n  return displayAllafterChangeSign;\n}","map":{"version":3,"names":["calculate","expression","regex","findExpression","displayAllafterChangeSign","displayAll","changeSign","state","lastResult","changeOneIntoAnother","before","afterChangeSign","arr","i","length","push","match","RegExp","slice","index","concat"],"sources":["C:/Users/agsaf/Documents/GitHub/calculator/src/functions/changeSign.js"],"sourcesContent":["import calculate from \"./equals\";\r\nimport { expression, regex, findExpression } from \"./findExpression\";\r\n\r\nexport let displayAllafterChangeSign = \"\";\r\nlet displayAll = \"\";\r\n\r\nexport function changeSign(state) {\r\n  displayAll = state.lastResult !== \"\" ? state.lastResult : state.displayAll;\r\n\r\n  let changeOneIntoAnother = [\r\n    // the sign will be changed from positive to negative or vice versa for:\r\n    // 1) the expression not preceded by operators (minus here indicates negative value of the following number rather than an operator sign)\r\n    {\r\n      before: \"\\\\(\",\r\n      afterChangeSign: \"( - \",\r\n    },\r\n    {\r\n      before: \"\\\\( - \",\r\n      afterChangeSign: \"(\",\r\n    },\r\n    {\r\n      before: \"^\",\r\n      afterChangeSign: \" - \",\r\n    },\r\n    {\r\n      before: \"^ - \",\r\n      afterChangeSign: \"\",\r\n    },\r\n\r\n    // 2) the expression preceded by two consecutive operators:\r\n    {\r\n      before: \" -  - \",\r\n      afterChangeSign: \" - \",\r\n    },\r\n    {\r\n      before: \" \\\\+  - \",\r\n      afterChangeSign: \" + \",\r\n    },\r\n    {\r\n      before: \" \\\\*  - \",\r\n      afterChangeSign: \" * \",\r\n    },\r\n    {\r\n      before: \" \\\\/  - \",\r\n      afterChangeSign: \" / \",\r\n    },\r\n    {\r\n      before: \" \\\\^  - \",\r\n      afterChangeSign: \" ^ \",\r\n    },\r\n    {\r\n      before: \" yroot  - \",\r\n      afterChangeSign: \" yroot \",\r\n    },\r\n    {\r\n      before: \" mod  - \",\r\n      afterChangeSign: \" mod \",\r\n    },\r\n    // 3) the expression preceded by only one operator:\r\n    {\r\n      before: \" - \",\r\n      afterChangeSign: \" + \",\r\n    },\r\n    {\r\n      before: \" \\\\+ \",\r\n      afterChangeSign: \" - \",\r\n    },\r\n    {\r\n      before: \" \\\\* \",\r\n      afterChangeSign: \" *  - \",\r\n    },\r\n    {\r\n      before: \" \\\\/ \",\r\n      afterChangeSign: \" /  - \",\r\n    },\r\n    {\r\n      before: \" \\\\^ \",\r\n      afterChangeSign: \" ^  - \",\r\n    },\r\n    {\r\n      before: \" yroot \",\r\n      afterChangeSign: \" yroot  - \",\r\n    },\r\n    {\r\n      before: \" mod \",\r\n      afterChangeSign: \" mod \",\r\n    },\r\n  ];\r\n\r\n  findExpression(state); // determines the expression for which changeSign(state) function will be applied to\r\n\r\n  let arr = [];\r\n  for (let i = 0; i < changeOneIntoAnother.length; i++) {\r\n    arr.push(displayAll.match(new RegExp(`${changeOneIntoAnother[i][\"before\"]}${regex}$`)));\r\n  }\r\n  // console.log(\"displayAll\", displayAll);\r\n  // console.log(\"expression\", expression);\r\n  // console.log(\"final\", RegExp(displayAll.match(`${changeOneIntoAnother[2][\"before\"]}${expression}$`)));\r\n  // console.log(\"arr\", arr);\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] !== null) {\r\n      displayAllafterChangeSign = displayAll.slice(0, arr[i].index).concat(changeOneIntoAnother[i][\"afterChangeSign\"]).concat(expression);\r\n      break;\r\n    }\r\n  }\r\n  return displayAllafterChangeSign;\r\n}\r\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,UAAU;AAChC,SAASC,UAAU,EAAEC,KAAK,EAAEC,cAAc,QAAQ,kBAAkB;AAEpE,OAAO,IAAIC,yBAAyB,GAAG,EAAE;AACzC,IAAIC,UAAU,GAAG,EAAE;AAEnB,OAAO,SAASC,UAAU,CAACC,KAAK,EAAE;EAChCF,UAAU,GAAGE,KAAK,CAACC,UAAU,KAAK,EAAE,GAAGD,KAAK,CAACC,UAAU,GAAGD,KAAK,CAACF,UAAU;EAE1E,IAAII,oBAAoB,GAAG;EACzB;EACA;EACA;IACEC,MAAM,EAAE,KAAK;IACbC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,QAAQ;IAChBC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,GAAG;IACXC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,MAAM;IACdC,eAAe,EAAE;EACnB,CAAC;EAED;EACA;IACED,MAAM,EAAE,QAAQ;IAChBC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,UAAU;IAClBC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,UAAU;IAClBC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,UAAU;IAClBC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,UAAU;IAClBC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,YAAY;IACpBC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,UAAU;IAClBC,eAAe,EAAE;EACnB,CAAC;EACD;EACA;IACED,MAAM,EAAE,KAAK;IACbC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,OAAO;IACfC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,OAAO;IACfC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,OAAO;IACfC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,OAAO;IACfC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,SAAS;IACjBC,eAAe,EAAE;EACnB,CAAC,EACD;IACED,MAAM,EAAE,OAAO;IACfC,eAAe,EAAE;EACnB,CAAC,CACF;EAEDR,cAAc,CAACI,KAAK,CAAC,CAAC,CAAC;;EAEvB,IAAIK,GAAG,GAAG,EAAE;EACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,oBAAoB,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;IACpDD,GAAG,CAACG,IAAI,CAACV,UAAU,CAACW,KAAK,CAAC,IAAIC,MAAM,CAAE,GAAER,oBAAoB,CAACI,CAAC,CAAC,CAAC,QAAQ,CAAE,GAAEX,KAAM,GAAE,CAAC,CAAC,CAAC;EACzF;EACA;EACA;EACA;EACA;;EAEA,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACnC,IAAID,GAAG,CAACC,CAAC,CAAC,KAAK,IAAI,EAAE;MACnBT,yBAAyB,GAAGC,UAAU,CAACa,KAAK,CAAC,CAAC,EAAEN,GAAG,CAACC,CAAC,CAAC,CAACM,KAAK,CAAC,CAACC,MAAM,CAACX,oBAAoB,CAACI,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAACO,MAAM,CAACnB,UAAU,CAAC;MACnI;IACF;EACF;EACA,OAAOG,yBAAyB;AAClC"},"metadata":{},"sourceType":"module"}