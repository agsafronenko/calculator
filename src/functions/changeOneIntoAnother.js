export let changeOneIntoAnother = [
  // change for:
  // 1) the expression not preceded by operators
  {
    before: "\\(",
    afterChangeSign: "( - ",
    afterAbs: "(abs(",
    afterAfterDenomination: "((1 / (",
    afterTrigonometry: `(trigFunc(`,
  },
  {
    before: "\\( - ",
    afterChangeSign: "(",
    afterAbs: "(abs( - ",
    afterAfterDenomination: "((1 / ( - ",
    afterTrigonometry: `(trigFunc( - `,
  },
  {
    before: "^",
    afterChangeSign: " - ",
    afterAbs: "abs(",
    afterAfterDenomination: "(1 / (",
    afterTrigonometry: `trigFunc(`,
  },
  {
    before: "^ - ",
    afterChangeSign: "",
    afterAbs: "abs( - ",
    afterAfterDenomination: "(1 / ( - ",
    afterTrigonometry: `trigFunc( - `,
  },

  // 2) the expression preceded by two consecutive operators:
  {
    before: " -  - ",
    afterChangeSign: " - ",
    afterAbs: " - abs( - ",
    afterAfterDenomination: " - (1 / ( - ",
    afterTrigonometry: ` - trigFunc( - `,
  },
  {
    before: " \\+  - ",
    afterChangeSign: " + ",
    afterAbs: " + abs( - ",
    afterAfterDenomination: " + (1 / ( - ",
    afterTrigonometry: ` + trigFunc( - `,
  },
  {
    before: " \\*  - ",
    afterChangeSign: " * ",
    afterAbs: " * abs( - ",
    afterAfterDenomination: " * (1 / ( - ",
    afterTrigonometry: ` * trigFunc( - `,
  },
  {
    before: " \\/  - ",
    afterChangeSign: " / ",
    afterAbs: " / abs( - ",
    afterAfterDenomination: " / (1 / ( - ",
    afterTrigonometry: ` / trigFunc( - `,
  },
  {
    before: " \\^  - ",
    afterChangeSign: " ^ ",
    afterAbs: " ^ abs( - ",
    afterAfterDenomination: " ^ (1 / ( - ",
    afterTrigonometry: ` ^ trigFunc( - `,
  },
  {
    before: " yroot  - ",
    afterChangeSign: " yroot ",
    afterAbs: " yroot abs( - ",
    afterAfterDenomination: " yroot (1 / ( - ",
    afterTrigonometry: ` yroot trigFunc( - `,
  },
  {
    before: " mod  - ",
    afterChangeSign: " mod ",
    afterAbs: " mod abs( - ",
    afterAfterDenomination: " mod (1 / ( - ",
    afterTrigonometry: ` mod trigFunc( - `,
  },
  // 3) the expression preceded by only one operator:
  {
    before: " - ",
    afterChangeSign: " + ",
    afterAbs: " - abs(",
    afterAfterDenomination: " - (1 / (",
    afterTrigonometry: ` - trigFunc(`,
  },
  {
    before: " \\+ ",
    afterChangeSign: " - ",
    afterAbs: " + abs(",
    afterAfterDenomination: " + (1 / (",
    afterTrigonometry: ` + trigFunc(`,
  },
  {
    before: " \\* ",
    afterChangeSign: " *  - ",
    afterAbs: " * abs(",
    afterAfterDenomination: " * (1 / (",
    afterTrigonometry: ` * trigFunc(`,
  },
  {
    before: " \\/ ",
    afterChangeSign: " /  - ",
    afterAbs: " / abs(",
    afterAfterDenomination: " / (1 / (",
    afterTrigonometry: ` / trigFunc(`,
  },
  {
    before: " \\^ ",
    afterChangeSign: " ^  - ",
    afterAbs: " ^ abs(",
    afterAfterDenomination: " ^ (1 / (",
    afterTrigonometry: ` ^ trigFunc(`,
  },
  {
    before: " yroot ",
    afterChangeSign: " yroot  - ",
    afterAbs: " yroot abs(",
    afterAfterDenomination: " yroot (1 / (",
    afterTrigonometry: ` yroot trigFunc(`,
  },
  {
    before: " log base ",
    afterChangeSign: " log base ",
    afterAbs: " log base abs(",
    afterAfterDenomination: " log base (1 / (",
    afterTrigonometry: ` log base trigFunc(`,
  },
  {
    before: " mod ",
    afterChangeSign: " mod ",
    afterAbs: " mod abs(",
    afterAfterDenomination: " mod (1 / (",
    afterTrigonometry: ` mod trigFunc(`,
  },
];
